# Стандарт разработки Frontend UI (v1) — React Islands + Tabler

**Цель:** Быстро развивать интерактивные дашборды и виджеты, не ломая монолитный Symfony/Twig UI.
**Принцип:** React внедряется исключительно как *острова (widgets)* внутри Twig. Основной стиль и верстка строго базируются на **Tabler UI**.

---

## 1. Границы применимости React

**✅ Строго используем React для:**

* Интерактивных дашбордов (виджеты, фильтры на лету, переключения периодов).
* Сложных визуализаций (графики, сводные таблицы).
* Высокоинтерактивных элементов (drag-and-drop, большие списки с виртуализацией, real-time обновления).
* Компонентов, которые живут на API и требуют частой перерисовки состояния.

**❌ Категорически НЕ используем React для:**

* Базовых CRUD-страниц, простых форм и статических списков.
* Детальных страниц просмотра сущностей.
* Глобальной навигации сайта, layout, sidebar/topbar (это зона ответственности Twig + Tabler).

---

## 2. Архитектура: Islands (Острова) внутри Twig

* **Изоляция:** Каждая React-зона монтируется в заранее подготовленный `div`-контейнер на странице, отрендеренной через Twig.
* **Первичные данные:** Передаются из Symfony при инициализации через `data-*` атрибуты или сериализованный JSON-скрипт (чтобы избежать лишних стартовых запросов к API).
* **Маршрутизация:** Symfony полностью контролирует роуты, проверку прав, контекст активной компании и lock-периоды. React не использует роутер (SPA исключено), он отвечает **только за UI** конкретного виджета.

---

## 3. Структура директорий (Feature-first)

Разработка ведется от фичи к фиче. Код не сваливается в общую кучу.

```text
assets/react/
├── app/                  # Общий bootstrap (init/mount скрипты, глобальные провайдеры)
├── shared/               # Общие UI-компоненты. Правило: попадают сюда только после 2+ использований
└── dashboard/            # Изолированный модуль (например, Dashboard v1)
    ├── widgets/          # Самостоятельные React-острова (например, CashFlowWidget)
    ├── components/       # Внутренние "глупые" компоненты для виджетов
    ├── api/              # API-клиенты (fetch/axios) конкретно для дашборда
    ├── types/            # TypeScript интерфейсы и DTO
    └── pages/            # (Опционально) Если внутри большого острова есть локальный мини-роутинг

```

---

## 4. Сборка и Entry Points (Webpack Encore)

* **Меньше entry = проще деплой и кеширование.**
* Создаем **один entry-файл на крупную зону** (например, `dashboard-v1`), а не на каждый мелкий компонент.
* Внутри entry-скрипта происходит поиск всех контейнеров на странице и монтирование соответствующих виджетов.

---

## 5. UI, Стиль и Типографика (Strict Tabler)

* **Tabler — источник истины:** Используем CSS и готовые компоненты Tabler (cards, grid, typography, buttons).
* **Tailwind:** Допускается исключительно как utility-инструмент (отступы, цвета), но базовые классы Tabler в приоритете.
* **Типовые паттерны:**
* Layout: `container-xl`, `row`, `col-*`
* Cards: `card`, `card-header`, `card-body`
* Buttons: `btn`, `btn-primary`, `btn-outline-*`
* States: `placeholder`, `empty`, `alert`, `spinner-border`


* **Типографика:** По умолчанию `font-weight: 400`. Жирное начертание (`600`) используется только точечно (заголовки, Call-to-Action). Никакого "жирного UI везде".
* **Кастомный CSS:** Строго избегаем. Если жизненно необходим — пишем локально (CSS Modules) и минимально.

---

## 6. Контракт данных (API) и Состояние

* **Формат данных:** React никогда не получает сырые Doctrine Entity. Только стабильные DTO.
* **Финансовые данные и даты:**
* Даты строго в формате `ISO-8601`.
* Деньги передаются в копейках/центах + валюта: `{ "amount": 100050, "currency": "RUB" }`.


* **Изменения API:** Любой breaking change в контракте = отдельный PR и согласование.
* **State Management (v1):** По умолчанию используем локальный state (`useState`, `useReducer`) и кастомные хуки. Внедрение Redux/Zustand допускается *только* при реальном конфликте состояний между сложными компонентами, но не "про запас".

---

## 7. UX и Обязательные состояния виджетов

Каждый виджет, работающий с сетью, **обязан** корректно обрабатывать 4 состояния (никаких "пустых белых экранов"):

1. `loading` (скелетоны или спиннеры).
2. `empty` (понятная заглушка, если данных за период нет).
3. `error` (человекочитаемое сообщение об ошибке с кнопкой повтора).
4. `success` (успешный рендер данных).

*Для списков сообщений или финансовых операций: если данных много, обязательно используется виртуализация, пагинация или ленивая подгрузка. Всю историю за год в память не грузим.*

---

## 8. Безопасность и Naming Conventions

* **Авторизация:** Источник истины — только сервер. Фронтенд может скрывать кнопки по ролям, но финальная валидация (включая проверку lock-периодов активной компании) происходит на бэкенде.
* **Мутации:** Все POST/PUT/DELETE запросы должны включать CSRF-токен (если используется session-based авторизация).
* **Нейминг:**
* Компоненты: `PascalCase.tsx` (например, `RevenueWidget.tsx`)
* Хуки: `useSomething.ts` (например, `useCashFlow.ts`)
* API/Типы: `*/api/*.ts`, `*/types/*.ts`



---

## 9. Definition of Done (DoD) для React-виджета

Виджет считается готовым к код-ревью, если:

* [ ] Визуально и структурно соответствует системе Tabler UI.
* [ ] Реализованы и оттестированы все 4 состояния: `loading`, `empty`, `error`, `success`.
* [ ] Работает через API Symfony с соблюдением контрактов (DTO, деньги в минимальных единицах).
* [ ] Не ломает и не дублирует существующий Twig UI.
* [ ] Оформлен как атомарный PR (без массового рефакторинга чужого кода).
* [ ] Пройден ручной smoke-тест (минимум 1 happy-path и 1 error-path).

---

Нужно ли подготовить эталонный код обертки (HOC или базовый компонент), который автоматически заставляет разработчика реализовать все 4 обязательных состояния (`loading`, `empty`, `error`, `success`), чтобы никто не забывал про заглушки и спиннеры?
