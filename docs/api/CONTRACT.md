# API Contract Standard (v1)

Документ фиксирует единые правила API для сервиса «Ваш Финдир», чтобы контракт не превратился в “зоопарк”.

## 1) API — только через DTO
API **не возвращает Doctrine Entity** и не принимает Entity-структуры.  
Только явные `RequestDTO` / `ResponseDTO`.

## 2) Контракт живёт в коде модуля
Для каждого модуля:
- `src/<Module>/Api/Request/*`
- `src/<Module>/Api/Response/*`

DTO — часть контракта. Контроллеры используют DTO напрямую или через mapper.

## 3) Один endpoint — один owner module
Каждый endpoint принадлежит ровно одному модулю (`src/<Module>`).  
Запрещены “общие контроллеры на всё” без владельца.

## 4) Имена эндпоинтов: ресурсы, не действия
URI строится от ресурсов (существительных), действия — через HTTP-методы.  
Пример: `POST /api/cash/transactions` (а не `/api/addTransaction`).

## 5) Версионирование: только через vN при breaking changes
Breaking change = новый путь `/api/v2/...` или новый endpoint.  
Нельзя “ломать” существующий response в рамках v1.

## 6) Формат дат и времени
- Все даты/время в **ISO-8601**.
- Если есть timezone — явно в строке.
- Если timezone не передаём — считаем в timezone компании (серверная логика).

## 7) Деньги и валюты
Деньги передаются как:
- `amount`: integer (в минорных единицах: копейки/центы)
- `currency`: string (`RUB`, `USD`, …)

Никаких float для денег.

## 8) Идентификаторы
- Внешние идентификаторы сущностей: `id` (UUID string).
- Никаких “магических” числовых id наружу, если в домене UUID.

## 9) Ошибки: единый формат
Любая ошибка отдаётся в едином формате:
- `type` (строка-код)
- `message` (человекочитаемо)
- `details` (опционально: объект/массив полей)

Валидация = `422 Unprocessable Entity`.

## 10) HTTP-коды (минимальный стандарт)
- `200` OK (GET/PUT/PATCH успешные)
- `201` Created (POST создал ресурс)
- `204` No Content (DELETE/операции без тела ответа)
- `400` Bad Request (невалидный запрос/формат)
- `401` Unauthorized
- `403` Forbidden
- `404` Not Found
- `409` Conflict (конфликт состояния)
- `422` Validation errors
- `500` Server error

## 11) Права и ограничения — на сервере
UI может скрывать кнопки, но источник истины — backend:
- company scope
- роли
- lock-period
- статусы документов

## 12) Мульти-тенантность: company scope обязателен
Любой endpoint работает в контексте активной компании:
- либо из session/контекста
- либо через явный `companyId` (только для admin/backoffice)

Запрещены ответы “чужих” данных.

## 13) Списки всегда с пагинацией
Любые списки (кроме справочников малого размера) возвращаются с пагинацией:
- `items`: array
- `pagination`: `{ page, perPage, total, pages }` (или аналог)

## 14) Сортировка и фильтры — только явные
Фильтры и сортировка описываются явно:
- `?sort=createdAt&dir=desc`
- `?from=...&to=...&status=...`

Запрещён “фильтр по любому полю” без whitelist.

## 15) Поля response: стабильные, без лишнего
Response DTO содержит только нужные UI поля.  
Запрещено “на всякий случай отдавать всё”.

## 16) Nullable — только по смыслу
Если поле может отсутствовать, это фиксируется явно:
- либо `null`
- либо поле отсутствует (выбрать один подход и не смешивать в рамках одного DTO)

## 17) Аудит и трассировка
Для критичных изменений (финансы/документы) backend пишет audit log.  
API не “верит фронту” в аудит-данные.

## 18) Изменение контракта = обновление DTO + документа
Любое изменение формата запроса/ответа требует:
- изменения DTO в модуле
- обновления этого файла `docs/api/CONTRACT.md`
- (если используем OpenAPI) обновления схемы

---

**DoD для нового endpoint:**
- есть `RequestDTO`/`ResponseDTO`
- соблюдены money/date/id правила
- ошибки в едином формате
- company scope и доступы проверяются
- списки — с пагинацией
